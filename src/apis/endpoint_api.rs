/*
 * EMnify Rest API
 *
 * Rest API resources of the EMnify System.
 *
 * The version of the OpenAPI document: 1.3
 *
 * Generated by: https://openapi-generator.tech
 */

use reqwest;

use super::{configuration, Error};
use crate::apis::ResponseContent;

/// struct for typed errors of method [`create_endpoint`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateEndpointError {
    Status404(crate::models::Model40xResponse),
    Status409(crate::models::Model40xResponse),
    Status422(crate::models::ChangePassword422Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_endpoint_data_quota_by_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteEndpointDataQuotaByIdError {
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_endpoint_sms_quota_by_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteEndpointSmsQuotaByIdError {
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`endpoint_balance_by_endpoint_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EndpointBalanceByEndpointIdDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`endpoint_balance_by_endpoint_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EndpointBalanceByEndpointIdGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`endpoint_balance_by_endpoint_id_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EndpointBalanceByEndpointIdPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`endpoint_by_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EndpointByIdDeleteError {
    Status404(),
    Status409(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`endpoint_by_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EndpointByIdGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`endpoint_by_id_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EndpointByIdPatchError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`endpoint_connectivity_by_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EndpointConnectivityByIdGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`endpoint_events_by_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EndpointEventsByIdError {
    Status400(),
    Status422(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`endpoint_operator_blacklist_by_endpoint_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EndpointOperatorBlacklistByEndpointIdGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`endpoint_operator_blacklist_by_ep_id_and_operator_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EndpointOperatorBlacklistByEpIdAndOperatorIdDeleteError {
    Status404(crate::models::Model40xResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`endpoint_operator_blacklist_by_ep_id_and_operator_id_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EndpointOperatorBlacklistByEpIdAndOperatorIdPutError {
    Status409(crate::models::Model40xResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`endpoint_quota_data_by_endpoint_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EndpointQuotaDataByEndpointIdGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`endpoint_quota_data_by_endpoint_id_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EndpointQuotaDataByEndpointIdPostError {
    Status422(crate::models::ChangeQuota422Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`endpoint_quota_sms_by_endpoint_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EndpointQuotaSmsByEndpointIdGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`endpoint_quota_sms_by_endpoint_id_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EndpointQuotaSmsByEndpointIdPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`endpoint_sms_by_endpoint_id_and_sms_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EndpointSmsByEndpointIdAndSmsIdDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`endpoint_sms_by_endpoint_id_and_sms_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EndpointSmsByEndpointIdAndSmsIdGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`endpoint_sms_by_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EndpointSmsByIdGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`endpoint_sms_by_id_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EndpointSmsByIdPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`endpoint_stats_by_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EndpointStatsByIdGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`endpoint_stats_daily_by_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EndpointStatsDailyByIdGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`endpoint_status_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EndpointStatusGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_connectivity_info_by_endpoint_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetConnectivityInfoByEndpointIdError {
    Status404(crate::models::CreateCloudConnectVpnRequest),
    Status503(crate::models::CreateCloudConnectVpnRequest),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_endpoints`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetEndpointsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_endpoint_connectivity_by_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateEndpointConnectivityByIdError {
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// If a `sim` object is provided, the SIM with the contained ID will be assigned to the endpoint. The `activate` property defaults to `true` and can be omitted unless the SIM should not be activated with this API call.  The following fields may be provided: * `name` (String required) * `service_profile` (Object required) * `tariff_profile` (Object required) * `status` (Object required) - `0` = __Enabled__, `1` = __Disabled__! * `tags` (String optional) * `imei` (String optional) * `imei_lock` (Boolean optional) * `sim` (Object optional)   - `id` (number required) SIM ID to be assigned to this endpoint   - `activate` (Boolean, optional, default:true) * `ip_address` (String optional) * `ip_address_space` (Object, optional if IP address is omitted, mandatory when IP address is set)
pub async fn create_endpoint(
    configuration: &configuration::Configuration,
    endpoint: crate::models::Endpoint,
) -> Result<(), Error<CreateEndpointError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/endpoint", local_var_configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&endpoint);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<CreateEndpointError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Will delete the data quota for the endpoint, if any is set. Note that if `apply_data_quota` is still set in the service profile, the endpoint will get blocked from data service.
pub async fn delete_endpoint_data_quota_by_id(
    configuration: &configuration::Configuration,
    endpoint_id: i32,
) -> Result<(), Error<DeleteEndpointDataQuotaByIdError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/api/v1/endpoint/{endpoint_id}/quota/data",
        local_var_configuration.base_path,
        endpoint_id = endpoint_id
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<DeleteEndpointDataQuotaByIdError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Will delete the SMS quota for the endpoint, if any is set. Note that if `apply_sms_quota` is still set in the service profile, the endpoint will get blocked from sending sms.
pub async fn delete_endpoint_sms_quota_by_id(
    configuration: &configuration::Configuration,
    endpoint_id: i32,
) -> Result<(), Error<DeleteEndpointSmsQuotaByIdError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/api/v1/endpoint/{endpoint_id}/quota/sms",
        local_var_configuration.base_path,
        endpoint_id = endpoint_id
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<DeleteEndpointSmsQuotaByIdError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// A `DELETE` request will reset the prepaid balance to a value of zero, in the current organisation currency. * Location updates will be rejected * PDP context requests will be rejected * MO-SMS will not be acknowledged and will time out
pub async fn endpoint_balance_by_endpoint_id_delete(
    configuration: &configuration::Configuration,
    endpoint_id: i32,
) -> Result<(), Error<EndpointBalanceByEndpointIdDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/api/v1/endpoint/{endpoint_id}/balance",
        local_var_configuration.base_path,
        endpoint_id = endpoint_id
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<EndpointBalanceByEndpointIdDeleteError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieves the balance of an Endpoint. The following properties are returned:  * `amount`: the current balance in currency with up to 6 decimal places of precision   * the amount may reach a negative value by deduction through the API or by deferred processing of usage charges   * If the amount is 0 or negative, the endpoint will be blocked from using teleservices, specifically     * Location updates will be rejected     * PDP context requests will be rejected     * MO-SMS will not be acknowledged and will time out * `currency`: a nested object with info on the currency represented by the `amount` * `auto_reset`: if enabled, the balance will be set automatically to the last loaded amount at the beginning of the month * `last_loaded_amount`: the amount of the last top-up/patch transaction
pub async fn endpoint_balance_by_endpoint_id_get(
    configuration: &configuration::Configuration,
    endpoint_id: i32,
) -> Result<crate::models::RetrievePrepaidBalanceresponse, Error<EndpointBalanceByEndpointIdGetError>>
{
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/api/v1/endpoint/{endpoint_id}/balance",
        local_var_configuration.base_path,
        endpoint_id = endpoint_id
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<EndpointBalanceByEndpointIdGetError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// At any time, the prepaid balance of an endpoint can be updated either by adding or subtracting a certain amount. If the currency of the balance does not match the currency of the organisation, first a balance reset has to be issued. the currency doesn't have to be specified explicitly anymore.  The API expects the following parameters in the JSON body  * `amount` (number, required) - A positive or negative value with up to 6 decimal places of precision.  The new balance will be the sum of the old balance plus this amount. As given amounts may be negative, the result will be a deduction from the balance  * `expiry_date` (string, required) - A timestamp specifying an expiry date in the future
pub async fn endpoint_balance_by_endpoint_id_post(
    configuration: &configuration::Configuration,
    endpoint_id: i32,
    update_prepaid_balanceresponse: Option<crate::models::UpdatePrepaidBalanceresponse>,
) -> Result<(), Error<EndpointBalanceByEndpointIdPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/api/v1/endpoint/{endpoint_id}/balance",
        local_var_configuration.base_path,
        endpoint_id = endpoint_id
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&update_prepaid_balanceresponse);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<EndpointBalanceByEndpointIdPostError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Deletes an endpoint and all its child entities. Please ensure the endpoint does not have a SIM assigned, otherwise the deletion will fail.
pub async fn endpoint_by_id_delete(
    configuration: &configuration::Configuration,
    endpoint_id: i32,
) -> Result<(), Error<EndpointByIdDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/api/v1/endpoint/{endpoint_id}",
        local_var_configuration.base_path,
        endpoint_id = endpoint_id
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<EndpointByIdDeleteError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieves information on an endpoint with a given id.
pub async fn endpoint_by_id_get(
    configuration: &configuration::Configuration,
    endpoint_id: i32,
) -> Result<crate::models::Endpoint, Error<EndpointByIdGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/api/v1/endpoint/{endpoint_id}",
        local_var_configuration.base_path,
        endpoint_id = endpoint_id
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<EndpointByIdGetError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Updates the details of an endpoint.  You can provide following fields with this request: * `name` (String, optional) * `tags` (String, optional) * `status` (Object, optional) * `service profile` (Object, optional) * `tariff profile` (Object, optional) * `ip_address` (String, optional) * `ip_address_space` (Object optional if IP address is missing, mandatory when IP address is set) * `sim` (Object, optional) * `imei` (String, optional) * `imei_lock` (Boolean, optional)
pub async fn endpoint_by_id_patch(
    configuration: &configuration::Configuration,
    endpoint_id: i32,
    update_endpoint: crate::models::UpdateEndpoint,
) -> Result<(), Error<EndpointByIdPatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/api/v1/endpoint/{endpoint_id}",
        local_var_configuration.base_path,
        endpoint_id = endpoint_id
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&update_endpoint);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<EndpointByIdPatchError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve details about current connectivity status of endpoint. The following is a list of possible statuses:  * `ATTACHED`: The Endpoint has succesfully attached to the Home Core network in the past. The device will be shown as `ATTACHED` until the visited network has signaled that the device is inactive/offline. Usually the visited network informs the Core Network within 1-2 days after a device went offline.  * `ONLINE`: The Endpoint has an active data connection  * `OFFLINE`: The Endpoint has not attached to the core network yet or the device was previously attached but the visited network signaled that the device had no activity for the last 1-2 days. Note: The device is not reachable for external services (e.g. SMS, MSRN lookup).  * `BLOCKED`: The device is not granted service. Endpoints are assigned this status when they have exceeded traffic limits.
pub async fn endpoint_connectivity_by_id_get(
    configuration: &configuration::Configuration,
    endpoint_id: i32,
) -> Result<
    crate::models::RetrieveEndpointConnectivityStatusresponse,
    Error<EndpointConnectivityByIdGetError>,
> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/api/v1/endpoint/{endpoint_id}/connectivity",
        local_var_configuration.base_path,
        endpoint_id = endpoint_id
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<EndpointConnectivityByIdGetError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns the list of events, filtered, sorted and paged according to query parameters.  **Note:** A full list of events is found in section \"Retrieve Event Types\" (`/api/v1/event/type`).  **CAUTION** This API endpoint deviates from the specified conventions and may not return the same HTTP Codes as the higher layer call (`/api/v1/endpoint/{endpoint_id}`). In case the requested `{endpoint_id}` does not exist or is not accessible for the user, **HTTP 200** will be returned with empty **[]** as long as the provided `{endpoint_id}` is a number and all parameters are valid. Please take that into consideration when building automation on top of the error behaviour of this endpoint.
pub async fn endpoint_events_by_id(
    configuration: &configuration::Configuration,
    endpoint_id: i32,
    page: Option<i32>,
    per_page: Option<i32>,
    sort: Option<&str>,
    q: Option<&str>,
) -> Result<crate::models::RetrieveEventsresponse, Error<EndpointEventsByIdError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/api/v1/endpoint/{endpoint_id}/event",
        local_var_configuration.base_path,
        endpoint_id = endpoint_id
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page {
        local_var_req_builder =
            local_var_req_builder.query(&[("page", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = per_page {
        local_var_req_builder =
            local_var_req_builder.query(&[("per_page", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = sort {
        local_var_req_builder =
            local_var_req_builder.query(&[("sort", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = q {
        local_var_req_builder = local_var_req_builder.query(&[("q", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<EndpointEventsByIdError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns a list of blacklisted Operators for the requested Endpoint
pub async fn endpoint_operator_blacklist_by_endpoint_id_get(
    configuration: &configuration::Configuration,
    endpoint_id: i32,
) -> Result<
    Vec<crate::models::RetrieveOperatorBlacklistresponse>,
    Error<EndpointOperatorBlacklistByEndpointIdGetError>,
> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/api/v1/endpoint/{endpoint_id}/operator_blacklist",
        local_var_configuration.base_path,
        endpoint_id = endpoint_id
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<EndpointOperatorBlacklistByEndpointIdGetError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Remove Operator from the Blacklist of an Endpoint.
pub async fn endpoint_operator_blacklist_by_ep_id_and_operator_id_delete(
    configuration: &configuration::Configuration,
    endpoint_id: i32,
    operator_id: f32,
) -> Result<(), Error<EndpointOperatorBlacklistByEpIdAndOperatorIdDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/api/v1/endpoint/{endpoint_id}/operator_blacklist/{operator_id}",
        local_var_configuration.base_path,
        endpoint_id = endpoint_id,
        operator_id = operator_id
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<EndpointOperatorBlacklistByEpIdAndOperatorIdDeleteError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Adds an Operator to the Blacklist of an Endpoint.
pub async fn endpoint_operator_blacklist_by_ep_id_and_operator_id_put(
    configuration: &configuration::Configuration,
    endpoint_id: i32,
    operator_id: f32,
) -> Result<(), Error<EndpointOperatorBlacklistByEpIdAndOperatorIdPutError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/api/v1/endpoint/{endpoint_id}/operator_blacklist/{operator_id}",
        local_var_configuration.base_path,
        endpoint_id = endpoint_id,
        operator_id = operator_id
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<EndpointOperatorBlacklistByEpIdAndOperatorIdPutError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns details about the assigned Data Quota for an endpoint. * `status`: this indicates the current status of the quota and may contain the following values:     - `ACTIVE`: the endpoint can currently connect and has quota left     - `EXHAUSTED`: the endpoint has exceeded the quota volume, if it still can use data service depends on the action chosen to be performed on exhaustion     - `EXPIRED`: the quota has expired; the endpoint is denied from using data services (until new quota is added) * `volume`: returns the volume left on this quota in MB * `expiry_date`: timestamp when this quota will expire and the endpoint will definitely be denied from using further data services (regardless if the quota volume was used up or not) * `peak_throughput`: The maximum bandwidth in octets per second after the endpoint has been throttled. * `action_on_exhaustion`: returns the behaviour defined to be applied when quota volume is used up (exhausted).     - `Throttle`: bandwidth will be throttle to the defined peak throughput until quota expires     - `Block`: data service will be instantly blocked once volume used up, regardless if the expiry date is already reached or not * `auto_refill`: 0 (false) / 1 (true), refill the quota with the last added volume on a daily basis
pub async fn endpoint_quota_data_by_endpoint_id_get(
    configuration: &configuration::Configuration,
    endpoint_id: i32,
) -> Result<crate::models::EndpointQuota, Error<EndpointQuotaDataByEndpointIdGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/api/v1/endpoint/{endpoint_id}/quota/data",
        local_var_configuration.base_path,
        endpoint_id = endpoint_id
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<EndpointQuotaDataByEndpointIdGetError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// At any time, a new data quota can be set for an endpoint. At an initial state when no data quota is set, the endpoint will be denied from using data services. To top-up the data volume you need to retrieve the currently remaining volume, increase it by the top-up volume and set it as the new quota volume.  The following parameters can be configured: * `status` - The status of the quota (mandatory):   - 1: `ACTIVE`   - 2: `EXHAUSTED`   - 3: `EXPIRED` * `volume`: The volume left on this quota in MB * `expiry_date`: Timestamp when this quota will expire and the endpoint will definitely be denied from using further data services (mandatory) * `auto_refill`: Wether the quota shall be refilled on a daily basis (defaults to disabled):   - 0: `disabled`   - 1: `enabled` * `threshold_percentage`: The percentage of remaining quota at which the system should generate a `threshold reached` event * `action_on_exhaustion`: The behaviour of the system after the quota is exhausted:   - id: ID of the action on quota exhaustion (mandatory)     - 1: `Block`     - 2: `Throttle`   - peak_throughput: The maximum bandwidth in octets per second after the endpoint has been throttled. (mandatory)   Allowed values are 64000, 128000, 256000, 384000. (will not take any effect on `action_on_exhaustion` \"Block\")  #### Events The system generates a \"Quota Used Up\" Event in case the data quota is completely depleted. The endpoint will be blocked from further consumption of data. The quota object will be included in the details of the event. Example events can be found in the Events of an Endpoint section.  #### Notes  The endpoint can instantly use data services after the API call to this entrypoint is successfully made. Any timestamp with a future date can be set, this allows to create data packages (e.g. for 1 hour, 24 hour, 7 days or any other timeframe) as required.
pub async fn endpoint_quota_data_by_endpoint_id_post(
    configuration: &configuration::Configuration,
    endpoint_id: i32,
    endpoint_quota: crate::models::EndpointQuota,
) -> Result<(), Error<EndpointQuotaDataByEndpointIdPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/api/v1/endpoint/{endpoint_id}/quota/data",
        local_var_configuration.base_path,
        endpoint_id = endpoint_id
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&endpoint_quota);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<EndpointQuotaDataByEndpointIdPostError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns details about the assigned SMS Quota for an endpoint.  You can retrieve the current SMS quota status for an endpoint with the following API call. It will return following properties: * `status`: this indicates the status of the quota and may contain the following values:   - `ACTIVE`: the endpoint has quota left and can use SMS services   - `EXHAUSTED`: the endpoint has exceeded the quota volume; the endpoint is denied from using SMS services (until new quota is added)   - `EXPIRED`: the quota has expired; the endpoint is denied from using SMS services (until new quota is added) * `volume`: the amount of SMS left on this quota * `expiry_date`: timestamp when this quota will expire and the endpoint will definitely be denied from using further SMS services (regardless if the quota volume was used up or not) * `threshold_percentage`: optional threshold in percentage indicating when a \"Threshold Reached\" event shall be sent. * `action_on_exhaustion`: returns the behaviour defined to be applied when quota volume is used up (exhausted).     - `Throttle`: bandwidth will be throttle to the defined peak throughput until quota expires     - `Block`: data service will be instantly blocked once volume used up, regardless if the expiry date is already reached or not     - `auto_refill`: 0 (false) / 1 (true), refill the quota with the last added volume on a daily basis
pub async fn endpoint_quota_sms_by_endpoint_id_get(
    configuration: &configuration::Configuration,
    endpoint_id: i32,
) -> Result<serde_json::Value, Error<EndpointQuotaSmsByEndpointIdGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/api/v1/endpoint/{endpoint_id}/quota/sms",
        local_var_configuration.base_path,
        endpoint_id = endpoint_id
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<EndpointQuotaSmsByEndpointIdGetError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// At any time, a new SMS quota can be set for an endpoint. At an initial state when no SMS quota is set, the endpoint will be denied from using SMS services. To top-up the SMS volume one need to retrieve the currently left volume, increase it by the top-up volume and set it as the new quota volume.  The following parameters can be configured: * `status` - The status of the quota (mandatory):   - 1: `ACTIVE`   - 2: `EXHAUSTED`   - 3: `EXPIRED` * `volume`: The volume left on this quota in MB * `expiry_date`: Timestamp when this quota will expire and the endpoint will definitely be denied from using further data services (mandatory) * `auto_refill`: Wether the quota shall be refilled on a daily basis (defaults to disabled):   - 0: `disabled`   - 1: `enabled` * `threshold_percentage`: The percentage of remaining quota at which the system should generate a `threshold reached` event * `action_on_exhaustion`: The behaviour of the system after the quota is exhausted:   - id: ID of the action on quota exhaustion (mandatory)     - 1: `Block`     - 2: `Throttle` (will not take any effect on SMS quota)   - peak_throughput: The maximum bandwidth in octets per second after the endpoint has been throttled.   Allowed values are 64000, 128000, 256000, 384000. (will not take any effect on SMS quota)  #### Notes  The endpoint can instantly use the SMS service after the API call is successfully made. Any timestamp with a future date can be set, this allows to create SMS packages (e.g. for 1 hour, 24 hour, 7 days or any other timeframe) as required
pub async fn endpoint_quota_sms_by_endpoint_id_post(
    configuration: &configuration::Configuration,
    endpoint_id: i32,
    sms_quota: crate::models::SmsQuota,
) -> Result<(), Error<EndpointQuotaSmsByEndpointIdPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/api/v1/endpoint/{endpoint_id}/quota/sms",
        local_var_configuration.base_path,
        endpoint_id = endpoint_id
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&sms_quota);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<EndpointQuotaSmsByEndpointIdPostError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Cancel SMS that is buffered for endpoint and not yet delivered.
pub async fn endpoint_sms_by_endpoint_id_and_sms_id_delete(
    configuration: &configuration::Configuration,
    endpoint_id: i32,
    sms_id: f32,
) -> Result<(), Error<EndpointSmsByEndpointIdAndSmsIdDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/api/v1/endpoint/{endpoint_id}/sms/{sms_id}",
        local_var_configuration.base_path,
        endpoint_id = endpoint_id,
        sms_id = sms_id
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<EndpointSmsByEndpointIdAndSmsIdDeleteError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns details about an Endpoint SMS by SMS ID.  A description of the SMS statuses is as follows:  - `1` DELIVERY ATTEMPT PENDING - `2` IN PROGRESS - `3` BUFFERED - `4` DELIVERED - `5` FAILED - `6` EXPIRED - `7` CANCELED
pub async fn endpoint_sms_by_endpoint_id_and_sms_id_get(
    configuration: &configuration::Configuration,
    endpoint_id: i32,
    sms_id: f32,
) -> Result<crate::models::GetdetailsofSmSresponse, Error<EndpointSmsByEndpointIdAndSmsIdGetError>>
{
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/api/v1/endpoint/{endpoint_id}/sms/{sms_id}",
        local_var_configuration.base_path,
        endpoint_id = endpoint_id,
        sms_id = sms_id
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<EndpointSmsByEndpointIdAndSmsIdGetError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns the list of SMS sent and received by this endpoint.  A description of the SMS statuses is as follows:  - `1` DELIVERY ATTEMPT PENDING - `2` IN PROGRESS - `3` BUFFERED - `4` DELIVERED - `5` FAILED - `6` EXPIRED - `7` CANCELED
pub async fn endpoint_sms_by_id_get(
    configuration: &configuration::Configuration,
    endpoint_id: i32,
) -> Result<Vec<crate::models::ListofSmSresponse>, Error<EndpointSmsByIdGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/api/v1/endpoint/{endpoint_id}/sms",
        local_var_configuration.base_path,
        endpoint_id = endpoint_id
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<EndpointSmsByIdGetError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Submit MT-SMS to specified endpoint.  You can provide following fields with this request:  * `payload` (String, required) - Message text to be sent, UTF-8 encoded * `source_address` (String, optional) - Source address of SMS: MSISDN, short code or alphanumeric String * `source_address_type` (Object optional) - Specify type of source address. Should contain an `id` property with a value of either:   - `145` - International   - `161` - National   - `208` - Alphanumeric * `expiry_date` (Date, optional) - Expiry date to retain the message until for successful sending. * `udh` (String, optional) - User Data Header encoded has hex-String. Concatenation of multiple SMS messages is done via this value. * `dcs` (Integer, optional) - Data Coding Scheme  #####  Concatenated SMSs  To concatenate SMS messages using `udh` properties, __multiple API calls__ should be made to this entrypoint.  More information on UDH properties can be found in the [3GPP 23.040 specification](https://portal.3gpp.org/desktopmodules/Specifications/SpecificationDetails.aspx?specificationId=747)
pub async fn endpoint_sms_by_id_post(
    configuration: &configuration::Configuration,
    endpoint_id: i32,
    submit_mt_sm_srequest: crate::models::SubmitMtSmSrequest,
) -> Result<(), Error<EndpointSmsByIdPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/api/v1/endpoint/{endpoint_id}/sms",
        local_var_configuration.base_path,
        endpoint_id = endpoint_id
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&submit_mt_sm_srequest);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<EndpointSmsByIdPostError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve usage and costs statistics for current/last month/hour. Data traffic costs can only be retrieved for organisations without inclusive volume.
pub async fn endpoint_stats_by_id_get(
    configuration: &configuration::Configuration,
    endpoint_id: i32,
) -> Result<crate::models::RetrieveEndpointStatisticsresponse, Error<EndpointStatsByIdGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/api/v1/endpoint/{endpoint_id}/stats",
        local_var_configuration.base_path,
        endpoint_id = endpoint_id
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<EndpointStatsByIdGetError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve usage and costs statistics accumulated per days. The statistics for the current month will be returned by default when no date parameters are provided.  The `start_date` and `end_date` query parameters can be provided to filter the returned results by date range. When a `start_date` is provided without an `end_date`, the statistics from the `start_date` until the end of the selected month will be returned.  Data traffic costs can only be retrieved for organisations without inclusive volume.
pub async fn endpoint_stats_daily_by_id_get(
    configuration: &configuration::Configuration,
    endpoint_id: i32,
    start_date: Option<String>,
    end_date: Option<String>,
) -> Result<serde_json::Value, Error<EndpointStatsDailyByIdGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/api/v1/endpoint/{endpoint_id}/stats/daily",
        local_var_configuration.base_path,
        endpoint_id = endpoint_id
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = start_date {
        local_var_req_builder =
            local_var_req_builder.query(&[("start_date", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = end_date {
        local_var_req_builder =
            local_var_req_builder.query(&[("end_date", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<EndpointStatsDailyByIdGetError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns a list of available Endpoint Statuses
pub async fn endpoint_status_get(
    configuration: &configuration::Configuration,
) -> Result<Vec<crate::models::Status>, Error<EndpointStatusGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/api/v1/endpoint/status",
        local_var_configuration.base_path
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<EndpointStatusGetError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns the connectivity information for the specified endpoint by ID.
pub async fn get_connectivity_info_by_endpoint_id(
    configuration: &configuration::Configuration,
    endpoint_id: i32,
    subscriber: Option<bool>,
    ussd: Option<bool>,
) -> Result<
    crate::models::RetrieveConnectivityInformationresponse,
    Error<GetConnectivityInfoByEndpointIdError>,
> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/api/v1/endpoint/{endpoint_id}/connectivity_info",
        local_var_configuration.base_path,
        endpoint_id = endpoint_id
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = subscriber {
        local_var_req_builder =
            local_var_req_builder.query(&[("subscriber", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = ussd {
        local_var_req_builder =
            local_var_req_builder.query(&[("ussd", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetConnectivityInfoByEndpointIdError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns the list of endpoints, filtered, sorted and paged according to query parameters.
pub async fn get_endpoints(
    configuration: &configuration::Configuration,
    q: Option<&str>,
    sort: Option<&str>,
    page: Option<i32>,
    per_page: Option<i32>,
) -> Result<Vec<crate::models::Endpoint>, Error<GetEndpointsError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/endpoint", local_var_configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = q {
        local_var_req_builder = local_var_req_builder.query(&[("q", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = sort {
        local_var_req_builder =
            local_var_req_builder.query(&[("sort", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page {
        local_var_req_builder =
            local_var_req_builder.query(&[("page", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = per_page {
        local_var_req_builder =
            local_var_req_builder.query(&[("per_page", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetEndpointsError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Dispatch a message that causes either a `Cancel Location` or `Delete PDP Context` or both sent to the endpoint. The return of the call does not yet mean the event has been sent towards the device.  Master organisation types can reset any endpoints inside their organisation hierarchy, enterprises may only reset connectivity of own endpoints.
pub async fn update_endpoint_connectivity_by_id(
    configuration: &configuration::Configuration,
    endpoint_id: i32,
    update_endpoint_connectivity_by_id_request: Option<
        crate::models::UpdateEndpointConnectivityByIdRequest,
    >,
) -> Result<(), Error<UpdateEndpointConnectivityByIdError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!(
        "{}/api/v1/endpoint/{endpoint_id}/connectivity",
        local_var_configuration.base_path,
        endpoint_id = endpoint_id
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&update_endpoint_connectivity_by_id_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<UpdateEndpointConnectivityByIdError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}
