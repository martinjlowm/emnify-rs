/*
 * EMnify Rest API
 *
 * Rest API resources of the EMnify System.
 *
 * The version of the OpenAPI document: 1.2.26
 *
 * Generated by: https://openapi-generator.tech
 */


use reqwest;

use crate::apis::ResponseContent;
use super::{Error, configuration};


/// struct for typed errors of method `sim_statistics_daily_by_id_get`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SimStatisticsDailyByIdGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `sim_by_id_delete`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SimByIdDeleteError {
    Status403(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `sim_by_id_get`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SimByIdGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `sim_by_id_patch`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SimByIdPatchError {
    Status400(crate::models::Response40x),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `sim_event_page_per_page_sort_by_sim_id_and_q_get`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SimEventPagePerPageSortBySimIdAndQGetError {
    Status400(),
    Status422(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `sim_per_page_sort_by_q_and_page_get`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SimPerPageSortByQAndPageGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `sim_stats_by_id_get`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SimStatsByIdGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `sim_status_get`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SimStatusGetError {
    UnknownValue(serde_json::Value),
}


/// Retrieve usage and costs statistics accumulated per days. Per default, the statistics for the current month will be returned. Data traffic costs can only be retrieved for organisations without inclusive volume.  To filter the statistics over a time range, a `start_date` and an `end_date` can be provided as query parameters. The filters have to be provided in `<property>=<value>` format.  When defining only the `start_date`, the statistics from that date until the end of the selected month will be returned.  Example request: `/api/v1/sim/123/stats/daily?end_date=2019-03-21&start_date=2019-03-01`
pub async fn sim_statistics_daily_by_id_get(configuration: &configuration::Configuration, sim_id: f32, start_date: Option<String>, end_date: Option<String>) -> Result<serde_json::Value, Error<SimStatisticsDailyByIdGetError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/api/v1/sim/{sim_id}/stats/daily", configuration.base_path, sim_id=sim_id);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_str) = start_date {
        local_var_req_builder = local_var_req_builder.query(&[("start_date", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = end_date {
        local_var_req_builder = local_var_req_builder.query(&[("end_date", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<SimStatisticsDailyByIdGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// **Warning: Deleted SIMs cannot be recovered!**  Deletes a SIM. The following restrictions apply to deleting SIMs:  * SIMs with an endpoint assigned cannot be deleted. * A reseller may not delete SIMs they have sold. If the SIM `reseller_org_id` field is not empty and matches the organization ID making the request, a `403` error will be returned.
pub async fn sim_by_id_delete(configuration: &configuration::Configuration, sim_id: f32) -> Result<(), Error<SimByIdDeleteError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/api/v1/sim/{sim_id}", configuration.base_path, sim_id=sim_id);
    let mut local_var_req_builder = local_var_client.delete(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<SimByIdDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve SIM details for a given ID.
pub async fn sim_by_id_get(configuration: &configuration::Configuration, sim_id: f32) -> Result<serde_json::Value, Error<SimByIdGetError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/api/v1/sim/{sim_id}", configuration.base_path, sim_id=sim_id);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<SimByIdGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Update SIM resource.  You can provide the following fields with this request: * `issuer_organisation` (Object optional) - can be changed to a direct child organisation of appropriate type * `reseller_organisation` (Object optional) - can be changed to a direct child organisation of appropriate type or emptied (`\"reseller_org\":{\"id\": null}` or `\"reseller_org\":{}`) * `customer_organisation` (Object optional) - can be changed to own organisation or a direct child organisation of type \"Enterprise\" or emptied (`\"customer_org\":{\"id\": null}` or `\"customer_org\":{}`) * `status` (Object optional)  #### Notes on update restrictions:  * A user of the Issuer organisation can update any of the updateable fields * A user of the Reseller organisation can update the fields: reseller_org, customer_org * A user of the Customer organisation can only update the status field * The issuer_org can be updated to a child organisation of type \"Mobile Network Operator\" or \"Service Provider\" * The reseller_org can be updated to a child organisation of type \"Mobile Network Operator\" or \"Service Provider\" or \"Reseller\" * The customer_org can be updated to a child organisation of type \"Enterprise\" * The status can be updated from id 0 (\"Issued\") only to id 1 (\"Activated\") * The status can also be updated between id 1 (\"Activated\") and id 2 (\"Suspended\") back and forth
pub async fn sim_by_id_patch(configuration: &configuration::Configuration, sim_id: f32, update_sim_request: crate::models::UpdateSIMRequest) -> Result<(), Error<SimByIdPatchError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/api/v1/sim/{sim_id}", configuration.base_path, sim_id=sim_id);
    let mut local_var_req_builder = local_var_client.patch(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&update_sim_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        Ok(())
    } else {
        let local_var_entity: Option<SimByIdPatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns the list of events, filtered, sorted and paged according to query parameters.  **CAUTION** This API endpoint deviates from the specified conventions and may not return the same HTTP Codes as the higher layer call (`/api/v1/sim/{sim_id}`). In case the requested `{sim_id}` does not exist or is not accessible for the user, **HTTP 200** will be returned with empty **[]** as long as the provided `{sim_id}` is a number and all parameters are valid. Please take that into consideration when building automation on top of the error behaviour of this endpoint.
pub async fn sim_event_page_per_page_sort_by_sim_id_and_q_get(configuration: &configuration::Configuration, sim_id: f32, page: Option<f32>, per_page: Option<f32>, sort: Option<&str>, q: Option<&str>) -> Result<Vec<crate::models::RetrieveEventsresponse>, Error<SimEventPagePerPageSortBySimIdAndQGetError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/api/v1/sim/{sim_id}/event", configuration.base_path, sim_id=sim_id);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page {
        local_var_req_builder = local_var_req_builder.query(&[("page", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = per_page {
        local_var_req_builder = local_var_req_builder.query(&[("per_page", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = sort {
        local_var_req_builder = local_var_req_builder.query(&[("sort", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = q {
        local_var_req_builder = local_var_req_builder.query(&[("q", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<SimEventPagePerPageSortBySimIdAndQGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns a list of SIMs, filtered, sorted and paged according to query parameters.
pub async fn sim_per_page_sort_by_q_and_page_get(configuration: &configuration::Configuration, page: Option<f32>, q: Option<&str>, per_page: Option<f32>, sort: Option<&str>) -> Result<Vec<crate::models::SingleSimResource>, Error<SimPerPageSortByQAndPageGetError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/api/v1/sim", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page {
        local_var_req_builder = local_var_req_builder.query(&[("page", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = q {
        local_var_req_builder = local_var_req_builder.query(&[("q", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = per_page {
        local_var_req_builder = local_var_req_builder.query(&[("per_page", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = sort {
        local_var_req_builder = local_var_req_builder.query(&[("sort", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<SimPerPageSortByQAndPageGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve usage and costs statistics for current/last month/hour. Data traffic costs can only be retrieved for organisations without inclusive volume.
pub async fn sim_stats_by_id_get(configuration: &configuration::Configuration, sim_id: f32) -> Result<Vec<crate::models::ResponseSchemaForSimStatistics>, Error<SimStatsByIdGetError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/api/v1/sim/{sim_id}/stats", configuration.base_path, sim_id=sim_id);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<SimStatsByIdGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieves a list of available statuses of SIMs.  * The initial state after the SIM has been registered to an account is 'Issued'. * Once you activate it the SIM becames 'Active'. * When you suspend the SIM its status is set to 'Suspended'.
pub async fn sim_status_get(configuration: &configuration::Configuration, ) -> Result<Vec<crate::models::ListofAllAvailableSimStatusesresponse>, Error<SimStatusGetError>> {

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/api/v1/sim/status", configuration.base_path);
    let mut local_var_req_builder = local_var_client.get(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if local_var_status.is_success() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<SimStatusGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}
